# -*- coding: utf-8 -*-
"""final_project.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1_C6kJbxn6ZG2A-HbGoM85ylggfr_JDz1
"""

! pip install kaggle

from google.colab import drive
drive.mount('/content/gdrive')

import os
os.environ['KAGGLE_CONFIG_DIR'] = "/content/gdrive/My Drive/Kaggle"

# Commented out IPython magic to ensure Python compatibility.
# %cd /content/gdrive/My Drive/Kaggle

!kaggle datasets download -d vencerlanz09/bottle-synthetic-images-dataset

!unzip \*.zip

import os
import PIL
import zipfile
import numpy as np
import tensorflow as tf
import shutil
import matplotlib.image as mpimg
import cv2
import matplotlib.pyplot as plt

from PIL import Image, ImageOps, ImageOps
from keras.models import load_model
from keras.preprocessing import image
from google.colab import files
from google.colab.patches import cv2_imshow
# from keras.src.engine import input_spec

import tensorflow as tf
device_name = tf.test.gpu_device_name()
if len(device_name) > 0:
    print("Found GPU at: {}".format(device_name))
else:
    device_name = "/device:CPU:0"
    print("No GPU, using {}.".format(device_name))

dataset_dir = '/content/gdrive/My Drive/Kaggle/Bottle Images/Bottle Images/'
train_dir = os.path.join(dataset_dir, 'train')
validation_dir = os.path.join(dataset_dir, 'validation')

def to_grayscale_then_rgb(image):
    if image.shape[2] == 1:
      return image

    image = tf.image.rgb_to_grayscale(image)
    return image

image_datagen = image.ImageDataGenerator(
    rescale                 =   1./255,
    rotation_range          =   20,
    horizontal_flip         =   True,
    vertical_flip           =   True,
    shear_range             =   0.2,
    zoom_range              =   0.24,
    validation_split        =   0.2,
    preprocessing_function  =   to_grayscale_then_rgb

)

# prepare data train and validation
training_generator = image_datagen.flow_from_directory(
    dataset_dir,
    target_size             =   (150, 150),
    class_mode              =   'categorical',
    color_mode              =   'grayscale',
    subset                  =   'training'
)

validation_generator = image_datagen.flow_from_directory(
    dataset_dir,
    target_size             =   (150, 150),
    class_mode              =   'categorical',
    color_mode              =   'grayscale',
    subset                  =   'validation'
)

tf.keras.preprocessing.image.load_img('/content/gdrive/My Drive/Kaggle/Bottle Images/Bottle Images/Beer Bottles/00000001.jpg')

tf.keras.preprocessing.image.load_img('/content/gdrive/My Drive/Kaggle/Bottle Images/Bottle Images/Plastic Bottles/00000001.jpg')

tf.keras.preprocessing.image.load_img('/content/gdrive/My Drive/Kaggle/Bottle Images/Bottle Images/Soda Bottle/00000001.jpg')

tf.keras.preprocessing.image.load_img('/content/gdrive/My Drive/Kaggle/Bottle Images/Bottle Images/Water Bottle/00000001.jpg')

tf.keras.preprocessing.image.load_img('/content/gdrive/My Drive/Kaggle/Bottle Images/Bottle Images/Wine Bottle/00000001.jpg')

class MyCallback(tf.keras.callbacks.Callback):
  def on_epoch_end(self, epoch, logs = {}):
    if (logs.get('acc') > 0.93):
      print('\nAkurasi mencapai 93%')
      self.model.stop_training = True

callback = MyCallback()

model = tf.keras.models.Sequential([

    tf.keras.layers.Conv2D(32, (3,3), activation='relu', input_shape=(150, 150, 1)),
    tf.keras.layers.MaxPooling2D(3, 2),
    tf.keras.layers.Conv2D(64, (3,3), activation='relu'),
    tf.keras.layers.MaxPooling2D(2,2),
    tf.keras.layers.Conv2D(128, (3,3), activation='relu'),
    tf.keras.layers.MaxPooling2D(2,2),
    tf.keras.layers.Conv2D(346, 1, activation='relu'),
    tf.keras.layers.MaxPooling2D(2,1),

    tf.keras.layers.Flatten(),

    tf.keras.layers.Dense(64, activation='relu'),
    tf.keras.layers.Dense(5, activation='softmax')
])

model.compile(
    metrics           =   ['acc'],
    loss              =   'categorical_crossentropy',
    optimizer         =   'adam'
)

r = model.fit(
    training_generator,
    validation_data   =   validation_generator,
    epochs            =   40,
    batch_size        =   5,
    callbacks         =   [callback]
)

# Create a figure with two subplots
plt.figure(figsize=(12, 5))

# Subplot for loss
plt.subplot(1, 2, 1)
plt.plot(r.history['loss'], label='loss', marker='o')
plt.plot(r.history['val_loss'], label='val_loss', marker='o')
plt.legend()
plt.title('Loss')

# Subplot for accuracy
plt.subplot(1, 2, 2)
plt.plot(r.history['acc'], label='acc', marker='o')
plt.plot(r.history['val_acc'], label='val_acc', marker='o')
plt.legend()
plt.title('Accuracy')

# Adjust spacing between subplots
plt.tight_layout()

# Show the plots
plt.show()

# Commented out IPython magic to ensure Python compatibility.
# %matplotlib inline

uploaded = files.upload()

for fn in uploaded.keys():
    # predicting images
    path = fn
    img = image.load_img(path, target_size=(150, 150))

    # Convert the image to grayscale
    x_gray = tf.image.rgb_to_grayscale(img)
    x_gray = tf.image.resize(x_gray, (150, 150))
    x_gray = tf.expand_dims(x_gray, axis=0)

    print("Input shape:", x_gray.shape)

    # Make predictions using the model
    classes = model.predict(x_gray)
    predicted_class = np.argmax(classes)
    print("Predicted classes:", predicted_class)

# Save the model in TF-Lite format
converter = tf.lite.TFLiteConverter.from_keras_model(model)
tflite_model = converter.convert()

# Save the TF-Lite model to a file
with open('model.tflite', 'wb') as f:
    f.write(tflite_model)